## Chapter 5. 변경 가능한 데이터 구조를 가진 언어에서 불변성 유지하기

데이터 구조 안에 데이터 구조가 들어있는 경우 데이터가 중첩되었다고 말한다.
어떻게 하면 중첩된 데이터에 대한 불변 동작을 유지할 수 있을까?

### 동작을 읽기, 쓰기 또는 둘 다로 분류하기

동작을 읽기 또는 쓰기 또는 둘 다 하는 것으로 분류할 수 있다.

- 어떤 동작은 **읽기**이다. 읽기 동작은 데이터를 바꾸지 않고 정보를 꺼내는 것이다.
  - 만약 인자에만 의존해 정보를 가져오는 읽기 동작이라면 계산이라고 할 수 있다.
- 다른 동작은 **쓰기**이다. 쓰기 동작은 어떻게든 데이터를 바꾼다.
  - 바뀌는 값은 어디서 사용될 지 모르기 때문에 바뀌지 않도록 원칙이 필요하다.

다시 정리해보자,

**읽기**

- 데이터에서 정보를 가져온다.
- 데이터를 바꾸지 않는다.
  **쓰기**
- 데이터를 바꾼다.

읽으면서 쓰는 동작은 어떠할까? 어떤 경우에는 데이터를 바꾸면서(쓰기) 동시에 정보를 가져오는(읽기) 경우도 있다.

### 카피-온-라이트 원칙 세 단계

카피-온-라이트는 세 단계로 되어 있다. 각 단계를 구현하면 카피-온-라이트로 동작한다.

예를 들어 장바구니 전역변수를 변경하는 동작을 모두 카피-온-라이트로 바꾸면, 장바구니는 더 이상 변경되지 않는다. 따라서 불변 데이터로 동작한다.

아래 세 단계로 카피-온-라이트를 적용하면 불변성을 유지하면서 값을 바꿀 수 있다.

1. 복사본 만들기
2. 본사본 변경하기(원하는 만큼)
3. 복사본 리턴하기

우리가 기억해야할 점은 카피-온-라이트는 쓰기를 읽기로 바꾼다는 것이다.

### 쓰기를 하면서 읽기도 하는 동작은 어떻게 해야 할까

어떤 동작은 읽고 변경하는 일을 동시에 한다. 이런 동작은 값을 변경하고 리턴한다.
어떻게 해야 할까? 두 가지 접근 방법이 있다.

1. 읽기와 쓰기 함수로 각각 분리한다.
2. 함수에서 값을 두 개 리턴한다.

선택할 수 있다면 첫 번째 접근 방법이 더 좋은 방법이다.
책임이 확실히 분리되기 때문이다.

### 쓰면서 읽기도 하는 함수 분리하기

쓰면서 읽기도 하는 함수를 분리하는 작업은 두 단계로 나눌 수 있다.
먼저 쓰기에서 읽기를 분리한다.
다음으로 쓰기에 카피-온-라이트를 적용해 읽기로 바꾼다.

읽기와 쓰기를 분리하는 접근 방법은 분리된 함수를 따로 쓸 수 있기 때문에 더 좋은 방법이다.

### 불변 데이터 구조를 읽는 것은 계산이다

**변경 가능한 데이터를 읽는 것은 액션이다.**
변경 가능한 값을 읽을 때마다 다른 값을 읽을 수도 있다. 따라서 변경 가능한 데이터를 읽는 것은 액션이다.

**쓰기는 데이터를 변경 가능한 구조로 만든다.**
쓰기는 데이터를 바꾸기 때문에 데이터를 변경 가능한 구조로 만든다.

**어떤 데이터에 쓰기가 없다면 데이터는 변경 불가능한 데이터이다.**
쓰기를 모두 없앴다면 데이터는 생성 이후 바뀌지 않는다. 따라서 불변 데이터이다.

**불변 데이터 구조를 읽는 것은 계산이다.**
어떤 데이터를 불변형으로 만들었다면 그 데이터에 모든 읽기는 계산이다.

**쓰기를 읽기로 바꾸면 코드에 계산이 많아진다.**
데이터 구조를 불변형으로 만들수록 코드에 더 많은 계산이 생기고 액션은 줄어든다.

### 어플리케이션에는 시간에 따라 변하는 상태가 있다.

변경 가능한 데이터 구조를 불변 데이터로 만드는 방법을 알아봤다.
하지만 데이터가 모두 불변형이면 어플리케이션에서 시간에 따라 변하는 상태를 어떻게 다뤄야 할까?

결국 모든 값을 불변형으로 만들더라도 시간에 따라 바뀌는 값을 다룰 수 있어야 한다.
이는 **교체**를 통해 이루어진다.

### 불변 데이터 구조는 충분히 빠르다.

- 언제든지 최적화할 수 있다.
- 가비지 콜렉터는 매우 빠르다.
- 생각보다 많이 복사하지 않는다.
  - 제품이 100개인 배열을 복사해도 참조만 복사함.
  - 데이터 구조의 최상위 단계만 복사하는 것을 얕은 복사라고 함.
  - 얕은 복사는 같은 메모리를 가리키는 참조에 대한 복사본을 만든다.
  - 이를 구조적 공유라고 한다.

### 객체에 대한 카피-온-라이트

Object.assign() 메서드를 이용하여 배열에서 slice() 메서드를 이용한 것처럼 복사를 구현하자.

```js
function setPrice(item, new_price) {
  var item_copy = Object.assign({}, item);
  item_copy.price = new_price;
  return item_copy;
}
```

> **얕은 복사**
> 얕은 복사는 중첩된 데이터 구조에 최상위 데이터만 복사한다. 예를 들어 객체가 들어있는 배열이 있다면 얕은 복사는 배열만 복사하고 안에 있는 객체는 참조로 공유한다.
> 두개의 중첩된 데이터 구조가 어떤 참조를 공유한다면 **구조적 공유**라고 한다. 데이터가 바뀌지 않는 불변 데이터 구조라면 구조적 공유는 안전하다. 구조적 공유는 메모리를 적게 사용하고, 모든 것을 복사하는 것보다 빠르다.

### 중첩된 쓰기를 읽기로 바꾸기

중첩된 쓰기도 중첩되지 않은 쓰기와 같은 패턴을 사용한다.
복사본을 만들고 변경한 다음 복사본을 리턴한다. 중첩된 항목에 또 다른 카피-온-라이트를 사용하는 부분만 다르다.

원래의 항목을 직접 변경하면 불변 데이터가 아니다. 배열의 항목은 바뀌지 않지만 배열 항목이 참조하는 값은 바뀐다. 이렇게 되면 불변 데이터가 아니다. 중첩된 모든 데이터 구조가 바뀌지 않아야 불변 데이터라고 할 수 있다.

이는 매우 중요한 개념이다. 최하위부터 최상위까지 중첩된 데이터 구조의 모든 부분이 불변형이어야한다.
중첩된 데이터의 일부를 바꾸려면 변경하려는 값과 상위의 모든 값을 복사해야 한다.

### 결론과 요점 정리

- 함수형 프로그래밍에서는 불변 데이터가 필요하다. 계산에서는 변경 가능한 데이터에 쓰기를 할 수 없다.
- 카피-온-라이트는 데이터를 불변형으로 유지할 수 있는 원칙이다. 복사본을 만들고 원본 대신 복사본을 변경하는 것을 말한다.
- 카피-온-라이트는 값을 변경하기 전에 얕은 복사를 한다. 그리고 리턴한다. 이렇게 하면 통제할 수 있는 범위에서 불변성을 구현할 수 있다.

### 논의 사항

우리는 그동안 **얕은 복사**를 이용한 **구조적 공유**에 대한 것을 생각하며 코드를 짰던 적이 있는가?

---
