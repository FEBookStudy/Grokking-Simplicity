# Chapter 8. 계층형 설계 I

## 계층형 설계란?
- 소프트웨어를 계층으로 구성하는 기술
- 각 계층을 정확히 구분하는 것은 어렵지만 좋은 설계를 위한 감각을 키우면 된다.

## 계층형 설계 패턴
다음은 계층형 설계에서 가장 중요한 네 가지 패턴이다.

1. **직접 구현**
2. **추상화 벽**
3. **작은 인터페이스** 
4. **편리한 계층**

### 패턴 1: 직접 구현
- 함수는 복잡하지 않게 표현되어야 한다.
- 코드를 작성하기 전에 코드의 동작에 대해 미리 정리하면 개선점을 쉽게 파악할 수 있다.

#### 예시 코드
아래 예시 코드를 보면 `freeTieClip` 내 반복문을 선언적으로 따로 함수로 로직을 빼서 사용하도록 변경했다. 
즉, 개선된 버전은 "무엇을" 할 것인지를 더 명확하게 표현한 것이다.

`isInCart` 함수는 저수준의 루프 로직을 추상화하여, 메인 함수가 더 높은 수준의 로직에 집중할 수 있게 해준다.

각 함수가 하나의 명확한 역할을 수행하도록 분리되어서 `freeTieClip`은 전체 로직을 관리하고, `isInCart`는 특정 아이템의 존재 여부만을 확인합니다. (단일 책임 원칙)

```ts
// Original freeTieClip function
function freeTieClip(cart) {
    var hasTie     = false;
    var hasTieClip = false;
    for(var i = 0; i < cart.length; i++) {
        var item = cart[i];
        if(item.name === "tie")
            hasTie = true;
        if(item.name === "tie clip")
            hasTieClip = true;
    }
    if(hasTie && !hasTieClip) {
        var tieClip = make_item("tie clip", 0);
        return add_item(cart, tieClip);
    }
    return cart;
}

// Optimized freeTieClip function
function freeTieClip(cart) {
    var hasTie = isInCart(cart, "tie");
    var hasTieClip = isInCart(cart, "tie clip");
    
    if(hasTie && !hasTieClip) {
        var tieClip = make_item("tie clip", 0);
        return add_item(cart, tieClip);
    }
    return cart;
}

function isInCart(cart, name) {
    for(var i = 0; i < cart.length; i++) {
        if(cart[i].name === name)
            return true;
    }
    return false;
}
```

반복문과 배열 인덱스 참조하는 기능은 `make_item`, `add_item` 보다 더 낮은 추상화 단계이기 때문에 `freeTieClip` **함수 내에서 서로 다른 추상화 단계를 사용하면 코드가 명확하지 않아 읽기 어렵다.** 

그래서 위 코드처럼 더 가까운 추상화 계층에 해당되는 `isInCart` 를 생성하고 이를 호출하는 것이다.

>**특정 함수 내에서 사용되는 함수가 모두 비슷한 계층에 있다면 직접 구현했다고 할 수 있다.**

#### 같은 계층에 있는 함수는 같은 목적을 가져야 한다.
- 추상화 수준이 높아질수록 구체적인 구현 사항은 신경 쓰지 않아도 된다.


### 3단계 줌 레벨
1. 전역 줌 레벨 - 그래프 전체 중 필요한 부분을 살펴볼 수 있다. (기본 레벨)
2. 계층 줌 레벨 - 한 계층과 연결된 바로 아래 계층을 볼 수 있다.
3. 함수 줌 레벨 - 함수 하나와 바로 아래 연결된 함수들을 볼 수 있다. 


>[!Note]
>직접 구현은 호출 화살표 길이를 줄이고 구체적인 구현을 감추는 것
>



모든 계층은 바로 아래 계층에 의존해야 한다. -> 커스텀 훅의 경우는 어떻게?



---


# Chapter 9. 계층형 설계 II

9장에서는 **추상화 벽, 작은 인터페이스, 편리한 계층 패턴**에 대한 내용을 다룬다.


## 패턴 2: 추상화 벽

해당 패던은 팀 간 책임을 명확하게 나누게 해준다.

>[!info]
>**추상화 벽이란?**
>세부 구현을 감춘 함수로 이루어진 계층이다.

따라서, 추상화 벽에 있는 함수를 사용할 때는 내부 구현체나 데이터 구조를 몰라도 사용할 수 있다. (신경 쓰지 않아도 된다.)
흔히 사용하는 라이브러리 및 API와 비슷하다. 

>**추상화 벽을 가로 지르는 함수 호출 화살표가 없어야 한다.**

추상화 벽을 가로 지르는 함수 호출이 있다면 추상화 벽에 새로운 함수를 만들면 된다.

### 추상화 벽은 언제 사용하면 좋을까?

1. 쉽게 구현을 바꾸기 위해 (의미에 대해 논의 필요)
2. 코드를 읽고 쓰기 쉽게 만들기 위해
3. 팀 간에 조율해야 할 것을 줄이기 위해
4. 주어진 문제에 집중하기 위해 
	- 사용하는 사람 입장에서 구체적인 부분만 무시할 수 있다는 게 맞는건가?


추상화 벽을 사용하면 추상화 벽의 아래, 위 코드의 의존성이 없어진다.

>코드를 쉽게 고치려고 추상화 벽을 사용하는 것은 아니다. 팀 간 커뮤니케이션 비용을 줄이고 복잡한 코드를 명확하기 위해 사용하는 것이 더 알맞다.

## 패턴 3: 작은 인터페이스
새로운 코드를 추가할 위치에 관한 패턴이다

>[!Info]
>작은 인터페이스 패턴은 새로운 기능을 만들 때 하위 계층에 기능을 추가, 수정하는 것이 아닌 상위 계층에 만드는 것을 의미한다.


다음은 추상화 벽을 작게 만들어야 하는 이유이다.

1. 추상화 벽에 코드가 많을수록 구현이 변경되었을 때 고쳐야 할 것이 많다.
2. 추상화 벽에 있는 코드는 낮은 수준의 코드이기 때문에 더 많은 버그가 있을 수 있다.
3. 낮은 수준의 코드는 이해하기 더 어렵다.
4. 추상화 벽에 코드가 많을수록 팀 간 조율해야 할 것도 많아진다.
5. 추상화 벽에 인터페이스가 많으면 알아야 할 것이 많아 사용하기 어렵다.

추상화 벽이랑 추상화 벽 위랑 무슨 차이가 있는지?

## 패턴 4: 편리한 계층

가상 이상적인 계층 구성을 만드는 방법에 대해 설명하는 패턴이다.

편리한 계층 패턴은 언제 패턴을 적용하고 또 언제 멈춰야 하는지 실용적인 방법을 알려준다.

작업하는 코드가 편리하다고 느끼면 설계는 멈춰도 된다. 


## 호출 그래프에 대해

**호출 그래프로 알 수 있는 세 가지 비기능적 요구사항**

1. 유지보수성(maintainability): 요구 사항이 바뀌었을 때 가장 쉽게 고칠 수 있는 코드는 어떤 코드인가요?
2. 테스트성(testability): 어떤 것을 테스트하는 것이 가장 중요한가요?
3. 재사용성(reusability): 어떤 함수가 재사용하기 좋나요?

재사용성이 높은 함수일수록 테스트성이 높을 것이다.

호출 그래프에서 위에 있을수록 수정이 용이하고 아래로 갈수록 어렵다.

따라서 그래프 하위에 있는 함수에 대한 테스트가 중요하다. 왜? 상위 계층 함수에서 다양하게 호출되어 사용되기 때문이다.


