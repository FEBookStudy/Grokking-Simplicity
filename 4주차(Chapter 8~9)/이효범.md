## Chapter 8. 계층형 설계 
이 책에서 다루려고 하는 **소프트웨어 설계**의 실용적인 정의는 다음과 같다.

**소프트웨어 설계**
- 코드를 만들고, 테스트하고, 유지보수하기 쉬운 프로그래밍 방법을 선택하기 위해 미적 감각을 사용하는 것

이번 챕터에서는 **계층형 설계**를 사용해 소프트웨어 설계를 위한 미적 감각을 키워보자.

---
## 계층형 설계란 무엇인가요?
**계층형 설계는 소프트웨어를 계층으로 구성하는 기술**이다.
각 계층에 있는 함수는 바로 아래 계층에 있는 함수를 이용해 정의합니다.

```
비즈니스 규칙 (cart_tax() 등)
👇
장바구니를 위한 동작들 (add_item() 등)
👇
카피-온-라이트 (add_element_last() 등)
👇
언어에서 지원하는 배열 관련 기능 (.slice() 등)
```

**계층을 잘 구분하려면 구분하기 위한 다양한 변수를 찾고,**
**찾은 것을 가지고 어떻게 해야 하는지 알아야 한다.**

이는 처음부터 쉬운 것은 아니다.

"가장 좋은 설계"를 위한 절대 공식과 그 공식을 만드는 변수는 많이 있지만 복잡하게 섞여 있어 찾기 어렵다.
하지만 좋은 설계를 위한 감각을 개발하고 그 감각을 따라가다보면 찾을 수 있다.

그렇다면 좋은 설계를 위한 감각은 어떻게 키울 수 있을까?

> **계층형 설계**
> 소프트웨어를 계층으로 구성하는 기술.

**계층형 설계 감각을 키우기 위한 ==입력==**
1. 함수 본문
	1. 길이
	2. 복잡성
	3. 구체화 단계
	4. 함수 호출
	5. 프로그래밍 언어의 기능 사용
2. 계층 구조
	1. 화살표 길이
	2. 응집도
	3. 구체화 단계
3. 함수 시그니처
	1. 함수명
	2. 인자 이름
	3. 인잣값
	4. 리턴값
**계층형 설계 감각을 키우기 위한 ==출력==**
1. 조직화
	1. 새로운 함수를 어디에 놓을 지 결정
	2. 함수를 다른 곳으로 이동
2. 구현
	1. 구현 바꾸기
	2. 함수 추출하기
	3. 데이터 구조 바꾸기
3. 변경
	1. 새 코드를 작성할 곳 선택하기
	2. 적절한 수준의 구체화 단계 결정하기

---
## 계층형 설계 패턴
여러 방향으로 계층형 설계에 대해 살펴볼 수 있지만, 그중 가장 중요한 네가지 패턴을 살펴보자.

1. **패턴 1: 직접 구현**
	- 직접 구현은 계층형 설계 구조를 만드는 데 도움이 된다. 직접 구현된 함수를 읽을 때, 함수 시그니처가 나타내고 있는 문제를 함수 본문에서 적절한 구체화 수준에서 해결해야 한다.
1. **패턴 2: 추상화 벽**
	- 호출 그래프에 **어떤 계층은 중요한 세부 구현을 감추고 인터페이스를 제공**한다. 인터페이스를 사용하여 코드를 만들면 높은 차원으로 생각할 수 있다. 고수준의 추상화 단계만 생각하면 되기 때문에 두뇌 용량의 한계를 극복할 수 있다.
2. **패턴 3: 작은 인터페이스**
	- **시스템이 커질수록** 비즈니스 개념을 나타내는 중요한 인터페이스는 작고 강력한 동작으로 구성하는 것이 좋다. 다른 동작도 직간접적으로 최소한의 인터페이스를 유지하면서 정의해야 한다.
3. **패턴 4: 편리한 계층**
	- 계층형 설계 패턴과 실천 방법은 개발자의 요구를 만족시키면서 **비즈니스 문제를 잘 풀 수 있어야** 한다. 소프트웨어를 더 빠르고 고품질로 제공하는 데 도움이 되는 계층에 시간을 투자해야 한다. 그냥 좋아서 계층을 추가하면 안된다. 코드와 그 코드가 속한 추상화 계층은 작업할 때 편리해야 한다.

---
## 패턴 1: 직접 구현
어떻게 하면 구현된 코드를 잘 읽을 수 있을까?
계층 구조는 아무리 강력한 기능을 하는 함수가 있더라도 복잡하지 않게 함수를 표현해야 한다.

```js
function freeTieClip(cart) {
	var hasTie = false;
	var hasTieClip = false;
	for(var i = 0; i < cart.length; i++) {
		var item = cart[i];
		if(item.name === 'tie') { // 넥타이가 있는지 확인
			hasTie = true;
		}
		if(item.name === 'tie clip') { // 넥타이 클립이 있는지 확인
			hasTieClip = true;
		} 
	}
	if(hasTie && !hasTieClip) {
		var tieClip = make_item("tie clip", 0);
		return add_item(cart, tieClip); // 넥타이 클립 추가
	}
	return cart;
}
```

어렵지 않은 코드이지만, 많은 기능이 있다. 장바구니를 돌면서 항목을 체크하고 무엇인가를 결정하고 있다.
이 코드는 제대로 설계하지 않고 그냥 기능을 추가한 것이다. 어떠한 설계 원칙을 가지고 설계하지 않았다.
이렇게 코드를 바로 추가하면 유지보수하기 어렵다.

==이 코드는 첫 번째 계층형 설계 패턴인 직접 구현을 따르지 않고 있다.==
freeTieClip() 함수가 알아야 할 필요가 없는 구체적인 내용을 담고 있다.

**장바구니가 해야할 동작**
설계를 개선하기 위해, 장바구니가 해야 할 동작을 정리해보기로 한다.
습관적으로 코드를 바로 작성하는 대신 해볼 수 있는 방법이다.

장바구니에 필요한 동작은 아래와 같다.
1. 제품 추가하기
2. 제품 삭제하기
3. 장바구니에 제품이 있는지 확인하기
4. 합계 계산하기
5. 장바구니 비우기
6. 제품 이름으로 가격 설정하기
7. 세금 계산하기
8. 무료 배송이 되는지 확인하기

**제품이 있는지 확인하는 함수가 있다면 설계를 개선할 수 있다.**
장바구니가 해야 할 동작을 모두 정리해보니 개선할 수 있는 부분을 발견했다.
freeTieClip() 함수에 직접 구현 패턴을 적용할 수 있을 것 같다.

> 장바구니 안에 제품이 있는지 확인하는 함수를 만들면 freeTieClip()을 더 명확하게 할 수 있을 것 같다.

즉, 장바구니 안에 제품이 있는지 확인하는 함수가 있다면, freeTieClip() 내에서 저수준의 반복문을 직접 쓰지 않을 수 있다.
저수준의 코드는 추출해야 할 가능성이 높다. 

```js
function isInCart(cart, name) {
	for(var i = 0; i < cart.length; i++) {
		if (cart[i].name === name) { 
			return true;
		}
	}
	return false;
}
```

==개선한 함수는 짧고 명확하다.== 또 모두 비슷한 구체화 수준에서 작동하고 있기 때문에 읽기 쉽다.


**호출 그래프를 만들어 함수 호출을 시각화하기**
freeTieClip 내부에서 함수 호출과 언어 기능을 호출 하는 부분을 시각화해보자.
직접 만든 함수와 언어 기능은 추상화 수준이 다르다.
예를 들어 반목문과 배열 인덱스를 참조하는 기능은 더 낮은 추상화 단계이다.
==한 함수에서 서로 다른 추상화 단계를 사용하면 코드가 명확하지 않아 읽기 어려울 수 있다.==


**직접 구현 패턴을 사용하면 비슷한 추상화 계층에 있는 함수를 호출한다.**
서로 다른 추상화 단계에 있는 기능을 사용하면 직접 구현 패턴이 아니다.
개선된 freeTieClip() 함수는 더 가까운 추상화 계층을 호출할 수 있게 된다.

```js
function freeTieClip(cart) {
	var hasTie = isInCart(cart, "tie");
	var hasTieClip = isInCart(cart, "tie clip");
	if (hasTie && !hasTieClip) {
		var tieClip = make_item("tie clip", 0);
		return add_item(cart, tieClip);
	}
	return cart;
}
```

개선된 freeTieClip() 함수를 살펴보자.
freeTieClip() 내부에 있는 함수들이 정확히 같은 추상화 단계인지 확실할 수 없지만 비슷한 추상화 단계를 사용하고 있는 것 같아 보인다.
조금 명확하지 않지만 괜찮다. 뒤에서 명확하게 하기 위해 다른 각도로 살펴볼 것이다.
지금은 freeTieClip() 함수가 장바구니 기능을 사용하기 위해 알아야 할 것이 무엇인지에 집중해 보자.
개선된 freeTieClip()은 장바구니가 배열로 되어 있는지 알아야 할까? 

개선된 함수에서는 장바구니가 배열인지 몰라도 된다. freeTieClip()이 사용하는 모든 함수는 장바구니가 배열인지 몰라도 된다. 
==장바구니가 배열인지 몰라도 된다는 것은 함수가 모두 비슷한 계층에 있는다는 것을 의미한다.==

> **이처럼 함수가 모두 비슷한 계층에 있다면 직접 구현했다고 할 수 있다.**

> **함수 이름은 함수가 어느 곳에 위치할 지 결정하기 위한 정보로 쓸 수 있다.**


**같은 계층에 있는 함수는 같은 목적을 가져야 한다**.
함수를 어떤 계층에 놓을지 선택하는 과정은 복잡하다. 그래도 계층이 서로 구분되는 목적이 있다면, 함수가 위치할 계층을 선택하는 데 좋은 정보로 사용할 수 있다. 계층의 목적은 각 계층에 있는 함수의 목적과 같다.

예를 들어 책에서는,
```
장바구니 비즈니스 규칙 
👇
일반적인 비즈니스 규칙
👇
장바구니 기본 동작
👇
제품에 대한 기본 동작
👇
카피-온-라이트 동작
👇
자바스크립트 언어 기능
```

각 계층은 추상화 수준이 다르다. 그래서 어떤 계층에 있는 함수를 읽거나 고칠 때 낮은 수준의 구체적인 내용은 신경쓰지 않아도 된다. 
예를 들어 '장바구니 비즈니스 규칙' 계층에 있는 함수를 쓸 때, 장바구니가 배열로 구현되어 있다는 것과 같은 구체적인 내용은 신경 쓰지 않아도 된다.

==직접 구현이 어떻게 계층형 설계에 도움이 될까?==

---
## 3단계 줌 레벨
계층형 설계에서 문제는 세 가지 다른 영역에서 찾을 수 있다.

1. 계층 사이에 상호 관계
2. 특정 계층의 구현
3. 특정 함수의 구현

문제를 찾기 위해 알맞은 줌 레벨을 사용해 하나의 영역을 살펴볼 수 있다.

### 1. 전역 줌 레벨
전역 줌 레벨로 그래프 전체 중 필요한 부분을 살펴볼 수 있다.
즉, 전역 줌 레벨이 기본 줌 레벨이다. 계층 사이에 상호 관계를 포함해서 모든 문제를 살펴볼 수 있다.

### 2. 계층 줌 레벨
계층 줌 레벨은 한 계층과 연결된 바로 아래 계층을 볼 수 있는 줌 레벨이다.
계층 줌 레벨로 계층이 어떻게 구현되어 있는지 알 수 있다.

### 3. 함수 줌 레벨
함수 줌 레벨로 함수 하나와 바로 아래 연결된 함수들을 볼 수 있다.
함수 줌 레벨로 함수 구현의 문제를 찾을 수 있다.

---

**계층 줌 레벨로 보면 함수가 가리키는 화살표를 계층 간에 비교할 수 있다.**
직접 구현 패턴을 사용하면 모든 화살표가 다이어그램 내에서 같은 길이를 가져야 한다.
이는 코드가 정돈되어 있지 않기 때문이다. 이러한 복잡함을 정리하기 위한 방법을 찾아야 한다.

**함수 줌 레벨을 사용하면 함수 하나가 가진 화살표를 비교할 수 있다.**
하나의 함수에 집중하면 함수가 가리키는 화살표를 모두 볼 수 있다.
함수 자신과 함수가 사용하는 언어 기능 그리고 다른 함수를 바라보도록 하자.

예를 들어 remove_item_by_name() 함수만 봐도, 서로 다른 계층의 동작을 사용하는 것을 확인할 수 있다.
이것은 직접 구현 패턴에 맞지 않는다.

직접 구현 패턴을 적용하면 remove_item_by_name()가 모두 같은 길이의 화살표를 가져야 한다.
어떻게 하면 화살표를 같은 길이로 만들 수 있을까?

==가장 일반적인 방법은 중간에 함수를 두는 것이다.==
언어 기능을 사용하는 긴 화살표를 줄여야 한다.

---

## 반복문 빼내기
remove_item_by_name() 함수에서 반복문을 빼서 새로운 함수로 만들어 보자.
현재 remove_item_by_name() 내의 반복문은 배열 안에 항목을 순서대로 확인해서 조건에 맞는 항목의 인덱스를 찾는다. 
이러한 로직을 따로 빼낸 indexOfItem()이라는 함수로 만들어 보자.

```js
function indexOfItem(cart, name) {
	for (var i = 0; i < cart.length; i++) {
		if (cart[i].name === name) {
			return i;
		}
	}
	return null;
}
```


---

```js
function isInCart(cart, name) {
	for(var i = 0; i < cart.length; i++) {
		if (cart[i].name === name) { 
			return true;
		}
	}
	return false;
}
```

```js
function indexOfItem(cart, name) {
	for (var i = 0; i < cart.length; i++) {
		if (cart[i].name === name) {
			return i;
		}
	}
	return null;
}
```

위의 isInCart() 함수와 indexOfItem() 함수는 비슷하게 생겼다.
비슷한 부분을 함께 쓸 수 있을까? 어떤 함수에서 다른 쪽 함수를 가져다 쓸 수 있을까?

==indexOfItem() 함수가 isInCart() 함수보다 더 낮은 수준의 함수이다.==

indexOfItem() 함수는 인덱스를 리턴하기 때문에 사용하는 곳에서 장바구니가 배열이라는 것을 알아야 한다.
반면, isInCart() 함수는 불리언값을 리턴하기 때문에 사용하는 곳에서 장바구니가 어떤 구조인지 몰라도 된다.

indexOfItem() 함수가 isInCart() 함수보다 더 낮은 수준에 있기 때문에 indexOfItem() 함수를 사용해 isInCart() 함수를 새롭게 만들 수 있다.

```js
function isInCart(cart, name) {
	return indexOfItem(cart, name) !== null;
}
```

재사용으로 코드가 더 짧아졌고 계층도 명확해지는 장점을 모두 얻었다.

---

## 직접 구현 패턴 리뷰
- 직접 구현한 코드는 한 단계의 구체화 수준에 관한 문제만 해결한다.
	- 직접 구현한 코드는 읽기 위해 알아야 하는 구체화 단계의 범위를 줄여준다.
- 계층형 설계는 특정 구체화 단계에 집중할 수 있게 도와준다.
- 호출 그래프는 구체화 단계에 대한 풍부한 단서를 보여준다.
	- 호출 그래프는 함수가 서로 연결되어 있는지 보여준다.
- 함수를 추출하면 더 일반적인 함수로 만들 수 있다.
	- 함수에 직접 구현 패턴을 적용하는 방법의 하나는 함수가 더 구체적인 내용을 다루지 않도록 함수를 일반적인 함수로 빼내는 것이다. 일반적인 함수는 보통 구체적인 내용을 하나만 다루기 때문에 테스트하기 쉽다. 명확한 코드와 알맞은 이름을 가진 함수는 더 읽기 쉽다.
- 일반적인 함수가 많을수록 재사용하기 좋다.
	- 구현을 명확하게 하기 위해 일반적인 함수를 빼낸다. 일반적인 함수는 구체적인 함수보다 더 많은 곳에서 쓸 수 있다.
- 복잡성을 감추지 않는다.
	- 계층형 설계에서 모든 계층은 바로 아래 계층에 의존해야 한다. 더 낮은 구체화 수준을 가진 일반적인 함수를 만들어 소프트웨어에 직접 구현 패턴을 적용해야 한다.

## 결론
계층 간 차이를 보기 위해 호출 그래프를 그려 코드를 시각화했다.
그리고 계층형 설계에서 가장 중요한 첫 번째 패턴인 직접 구현 패턴을 알아봤다.

직접 구현 패턴이 적용된 계층 구조로 만들면, 간단한 함수로 또 다른 간단한 함수를 만들면서 코드를 구성할 수 있다.
하지만 계층형 설계를 잘 만드는 방법은 더 있다. 다음 챕터에서 남은 세 개의 패턴을 살펴보자.


## 요점 정리
- 계층형 설계는 코드를 추상화 계층으로 구성한다. 각 계층을 볼 때 다른 계층에 구체적인 내용을 몰라도 된다.
- 문제 해결을 위한 함수를 구현할 때 어떤 구체화 단계로 쓸지 결정하는 것이 중요하다. 그래야 함수가 어떤 계층에 속할지 알 수 있다.
- 함수가 어떤 계층에 속할지 알려주는 요소는 많이 있다. 함수 이름과 본문, 호출 그래프 등이 그런 요소이다.
- 함수 이름은 의도를 알려준다. 비슷한 목적의 이름을 가진 함수를 함께 묶을 수 있다.
- 함수 본문은 중요한 세부 사항을 알려준다. 함수 본문은 함수가 어떤 계층 구조에 있어야 하는지 알려준다.
- 호출 그래프로 구현이 직접적이지 않다는 것을 알 수 있다. 함수를 호출하는 화살표가 다양한 길이를 가지고 있다면 직접 구현되어 있지 않다는 신호이다.
- 직접 구현 패턴은 함수를 명확하고 아름답게 구현해 계층을 구성할 수 있도록 알려준다.

---


# Chapter 9. 계층형 설계 II

## 패턴 2: 추상화 벽
**추상화 벽**은 여러가지 문제를 해결한다. 그 중 하나는 팀 간 책임을 명확하게 나누는 것이다.

## 추상화 벽으로 구현을 감춘다.
추상화 벽은 세부 구현을 감춘 함수로 이루어진 계층이다.
추상화 벽에 있는 함수를 사용할 때는 구현을 전혀 몰라도 함수를 쓸 수 있다.

함수형 프로그래머는 문제를 높은 수준으로 생각하기 위해 추상화 벽을 효과적인 도구로 사용한다.
예를 들어 마케팅팀은 지저분한 반복문이나 배열을 직접 다루지 않고 마케팅 코드를 만들기 위해 추상화 벽에 있는 함수를 사용할 수 있다.

---
## 세부적인 것을 감추는 것은 대칭적이다.
추상화 벽을 사용하면 마케팅팀이 세부 구현을 신경 쓰지 않아도 된다.
신경 쓰지 않아도 된다는 것은 대칭적이라는 것이다.
즉, 추상화 벽을 만든 개발팀은 추상화 벽에 있는 함수를 사용하는 마케팅 관련 코드를 신경 쓰지 않아도 된다.
결국 두 팀 모두 독립적으로 일할 수 있다.

추상화 벽이 흔하게 사용하는 라이브러리난 API와 비슷하다는 것을 느꼈을 것이다.

---
## 추상화 벽이 있으면 구체적인 것을 신경 쓰지 않아도 된다.
추상화 벽은 "어떤 것을 신경 쓰지 않아도 되지?" 라는 말을 거창하게 표현한 개념이다.
계층 구조에서 어떤 계층에 있는 함수들이 장바구니와 같이 공통된 개념을 신경 쓰지 않아도 된다면 그 계층을 추상화 벽이라고 할 수 있다.
추상화 벽은 필요하지 않은 것은 무시할 수 있도록 간접적인 단계를 만든다.

> 추상화 벽은 데이터 구조에 대해 신경 쓰지 않아도 된다는 것을 의미한다.

---
## 추상화 벽은 언제 사용하면 좋을까?
1. 쉽게 구현을 바꾸기 위해
	1. 구현에 대한 확신이 없는 경우 추상화 벽을 사용하면 구현을 간접적으로 사용할 수 있기 때문에 나중에 구현을 바꾸기 쉽다. 예를 들어 프로토타이핑과 같이 최선을 구현을 확실할 수 없는 작업에 유용하다. 다른 예로 서버에서 데이터를 받아서 처리해야 하지만 아직은 준비가 되지 않아 임시 데이터를 줘야 하는 경우와 같이 뭔가 바뀔 것을 알고 있지만 아직 준비되지 않은 경우에도 좋다.
2. 코드를 읽고 쓰기 쉽게 만들기 위해
	1. 추상화 벽을 사용하면 세부적인 것을 신경 쓰지 않아도 된다. 적절한 것을 감추면 숙련된 프로그래머가 아니라도 더 셍산적인 코드를 만들 수 있다.
3. 팀 간에 조율해야 할 것을 줄이기 위해
	1. 추상화 벽을 사용하면 각 팀에 관한 구체적인 내용을 서로 신경 쓰지 않아도 일할 수 있다. 게다가 더 빠르게 일할 수 있다.
4. 주어진 문제에 집중하기 위해
	1. 추상화 벽을 사용하면 문제를 해결하기 더 쉽다. 추상화 벽을 사용하면 해결하려는 문제의 구체적인 부분을 무시할 수 있다. 그렇기 때문에 오히려 코드에 실수를 줄이고, 만들면서 지치지 않을 수 있다.

---
## 패턴 2 리뷰: 추상화 벽
추상화 벽은 강력한 패턴이다. 추상화 벽으로 추상화 벽 아래에 있는 코드와 위에 있는 코드의 의존성을 없앨 수 있다. 서로 신경 쓰지 않아도 되는 구체적인 것을 벽을 기준으로 나눠서 서로 의존하지 않게 한다.

모든 추상화는 다음과 같이 동작한다.
- 추상화 단계의 상위에 있는 코드와 하위에 있는 코드는 서로 의존하지 않게 정의한다.
- 추상화 단계의 모든 함수는 비슷한 세부 사항을 무시할 수 있도록 정의한다.
- 바뀌지 않을지도 모르는 코드를 언젠가 쉽게 바꿀 수 있게 만들려는 함정에 빠지지 않아야 한다.
	- 추상화 벽을 사용하면 코드를 쉽게 고칠 수 있다.
	- 하지만 코드를 쉽게 고치려고 추상화 벽을 사용하는 것은 아니다.
- 추상화 벽은 팀 간에 커뮤니케이션 비용을 줄이고, 복잡한 코드를 명확하게 하기 위해 전략적으로 사용해야 한다.

신경 쓰지 않아도 되는 것을 다루는 것이 추상화 벽의 핵심이다.

---
## 패턴 3: 작은 인터페이스
설계 감각을 키우기 위한 세 번째 패턴은 **작은 인터페이스**이다.
==작은 인터페이스 패턴은 새로운 코드를 추가할 위치에 관한 것이다.==
==인터페이스를 최소화하면 하위 계층에 불필요한 기능이 쓸데없이 커지는 것을 막을 수 있다.==

새로운 기능을 만들 때 하위 계층에 기능을 추가하거나 고치는 것보다 상위 계층에 만드는 것이 작은 인터페이스 패턴이라고 할 수 있다. 
작은 인터페이스 패턴을 사용하면 하위 계층을 고치지 않고 상위 계층에서 문제를 해결할 수 있다.

**장바구니 로그를 남길 더 좋은 위치**
- 액션이 전체로 퍼져 나가지 않게 고려하기

## 패턴 3 리뷰: 작은 인터페이스
아래는 추상화 벽을 작게 만들어야 하는 이유

1. 추상화 벽에 코드가 많을수록 구현이 변경되었을 때 고쳐야 할 것이 많다.
2. 추상화 벽에 있는 코드는 낮은 수준의 코드이기 때문에 더 많은 버그가 있을 수 있다.
3. 낮은 수준의 코드는 이해하기 더 어렵다.
4. 추상화 벽에 코드가 많을수록 팀 간 조율해야 할 것도 많아진다.
5. 추상화 벽에 인터페이스가 많으면 알아야 할 것이 많아 사용하기 어렵다.

상위 계층에 어떤 함수를 만들 때 가능한 현재 계층에 있는 함수로 구현하는 것이 작은 인터페이스를 실천하는 방법이다.
함수가 하려는 목적을 잘 파악하고 어떤 계층에 구현하는 것이 적합할지 생각해보자.
일반적으로 그래프에서 상위 계층에 구현하는 것이 좋다.

- 이상적인 계층은 더도 덜도 아닌 필요한 함수만 가지고 있어야 한다.
- 계층이 가진 함수는 완전하고, 적고, 시간이 지나도 바뀌지 않아야 한다.
- 이것이 작은 인터페이스가 전체 계층에 사용되는 이상적인 모습이다.

---
## 패턴 4: 편리한 계층
앞에서 알아본 패턴 세 개는 계층을 구성하는 것에 관한 패턴이다.
세 개의 패턴은 가장 이상적인 계층 구성을 만드는 방법에 대해 설명하고 있다.
마지막으로 알아볼 네 번째 패턴은 **편리한 계층**이라고 하는 패턴이다.
다른 패턴과 다르게 조금 더 현실적이고 실용적인 측면을 다루고 있다.

계층형 설계 패턴과 실천 방법은 개발자의 요구를 만족시키면서 **비즈니스 문제를 잘 풀 수 있어야** 한다. 소프트웨어를 더 빠르고 고품질로 제공하는 데 도움이 되는 계층에 시간을 투자해야 한다. 그냥 좋아서 계층을 추가하면 안된다. 코드와 그 코드가 속한 추상화 계층은 작업할 때 편리해야 한다. 

---

- 기능적 요구사항
	- 소프트웨어가 정확히 해야 하는 일을 말한다.
- 비기능적 요구사항
	- 테스트를 어떻게 할 것인지
	- 재사용을 잘할 수 있는지
	- 유지보수하기 어렵지 않은지

비기능적 요구사항은 소프트웨어 설계를 하는 중요한 이유이다.

호출 그래프로 알 수 있는 세 가지 비기능적 요구사항
- 유지보수성
	- 요구 사항이 바뀌었을 때 쉽게 고칠 수 있는 코드인가?
- 재사용성
	- 함수가 재사용하기 좋은가?
- 테스트성

---
## 그래프의 가장 위에 있는 코드가 고치기 가장 쉽다
호출 그래프에서 가장 위에 있는 코드는 어디에서도 호출하지 않기 때문에 고치기 쉽다.
즉, 함수는 그래프 위에서 멀어질수록 더 고치기 어렵다.

자주 바뀌는 코드는 그래프 위에 있을수록 쉽게 일할 수 있다. 하지만 바뀌는 것이 많은 가장 높은 곳은 적게 유지하는 것이 좋다. 따라서 시간이 지나도 변하지 않는 코드는 가장 아래 계층에 있어야 한다.
앞에서 본 것처럼 카피-온-라이트 함수는 가장 낮은 계층에 있다. 이런 함수는 한번 잘 만들어 두면 바꿀 일이 없다. 

직접 구현 패턴처럼 함수를 추출해 더 낮은 계층으로 보내거나 작은 인터페이스 패턴처럼 더 높은 계층에 함수를 추가하는 일은 모두 변경 가능성을 생각해서 계층화하고 있는 것이다.

## 아래에 있는 코드는 테스트가 중요하다

모든 코드를 테스트 하는 것은 현실적이지 않다. 모든 것을 테스트할 수 없다면 장기적으로 좋은 결과를 얻기 위해 어떤 것을 테스트하는 것이 중요할까?

> 하위 계층 코드를 테스트 할수록 얻은 것이 더 오래간다.


### 아래에 있는 코드가 재사용하기 더 좋다.
낮은 계층으로 함수를 추출하면 재사용할 가능성이 많아지는 것을 봤다.
낮은 계층은 재사용하기 더 좋다. 계층형 설계 패턴을 적용하면 재사용 가능한 계층으로 코드를 만들 수 있다.

아래쪽으로 가리키는 화살표가 많은 함수는 재사용하기 어렵다.

## 요약: 그래프가 코드에 대해 알려주는 것

1. 유지보수성
	1. 규칙: 위로 연결된 것이 적은 함수가 바꾸기 쉽다.
	2. 핵심: 자주 바뀌는 코드는 가능한 위쪽에 있어야 한다.
2. 테스트 가능성
	1. 규칙: 위쪽으로 많이 연결된 함수를 테스트하는 것이 더 가치 있다.
	2. 핵심: 아래쪽에 있는 함수를 테스트하는 것이 위쪽에 있는 함수를 테스트하는 것보다 가치 있다.
3. 재사용성
	1. 규칙: 아래쪽에 함수가 적을수록 더 재사용하기 좋다.
	2. 핵심: 낮은 수준의 단계로 함수를 빼내면 재사용성이 더 높아진다.


## 결론
==계층형 설계는 바로 아래 계층에 있는 함수로 현재 계층의 함수를 구현해 코드를 구성하는 기술이다.==

## 요점 정리
- 추상화 벽 패턴을 사용하면 세부적인 것을 완벽히 감출 수 있기 때문에 더 높은 차원에서 생각할 수 있다.
- 작은 인터페인스 패턴을 사용하면 완성된 인터페이스에 가깝게 계층을 만들 수 있다. 중요한 비즈니스 개념은 표현하는 인터페이스는 한번 잘 만들어 놓고 더 바뀌거나 늘어나지 않아야 한다.
- 편리한 계층 패턴을 이용하면 다른 패턴을 요구 사항에 맞게 사용할 수 있다. 패턴을 사용하다 보면 너무 과한 추상화를 할 수 있다. 패턴들은 요구 사항에 맞게 적용해야 한다.
- 호출 그래프 구조에서 규칙을 얻을 수 있다. 이 규칙으로 어떤 코드를 테스트하는 것이 가장 좋은지, 유지보수나 재사용하기 좋은 코드는 어디에 있는 코드인지 알 수 있다.

---
