# Chapter 12. 함수형 반복

**살펴볼 내용**

- 함수향 도구 map(), filter(), reduce()에 대해 배운다.
- 배열에 대한 반복문을 함수형 도구로 바꾸는 방법에 대해 알아본다.
- 함수형 도구를 어떻게 구현하는지 알아본다.

## 함수형 도구: map()

```js
function map(array, f) {
  // 배열과 함수를 인자로 받는다.
  var newArray = []; // 빈 배열을 만든다.
  forEach(array, function (element) {
    newArray.push(f(element)); // 원래 배열 항목으로 새로운 항목을 만들기 위해 f() 함수를 부른다, 원래 배열 항목에 해당하는 새로운 항목을 추가한다.
  });
  return newArray; // 새로운 배열을 리턴한다.
}
```

map()은 X(어떤 값의 집합) 값이 있는 배열을 Y(또 다른 값의 집합) 값이 있는 배열로 변환한다고 볼 수 있다.
변환을 하려면 X를 Y로 바꾸는 함수가 필요하다.
X를 Y로 바꾸는 함수는 X를 인자로 받아 Y를 리턴해야 한다.
map()은 값 하나를 바꾸는 함수를 배열 전체를 바꾸는 데 사용할 수 있다.

> [!NOTE]
> map()에 넘기는 함수가 계산일 때 가장 사용하기 쉽다.
> map()에 계산을 넘기면 map()을 사용하는 코드도 계산이다.
> 하지만 map()에 액션을 넘기면 map()은 항목의 개수만큼 액션을 호출할 것이다.
> 결과적으로 map()을 사용하는 코드도 액션이 된다.

## 함수를 전달하는 세 가지 방법

> **인라인 함수**는 쓰는 곳에서 바로 정의하는 함수이다.
> 인자를 넘기는 곳에서 바로 정의한다면 인라인 함수인 것이다.

### 전역으로 정의하기

함수를 전역으로 정의하고 이름을 붙일 수 있다.

```js
function greet(name) {
  // 프로그램 한 곳에서 이름을 붙여 함수를 정의한다.
  return "Hello, " + name;
}

var friendGreetings = map(friendsNames, greet); // 어디서나 이름으로 함수를 참조할 수 있다. 이렇게 map()에 전달할 수 있다.
```

### 지역적으로 정의하기

함수를 지역 범위 안에서 정의하고 이름을 붙일 수 있다.
이름을 가지고 있지만 범위 밖에서는 쓸 수 없다.
지역적으로 쓰고싶지만 이름이 필요할 때 유용하다.

```js
function greetEverybody(friends) {
  // 이 함수 범위 안에 있다.
  var greeting;
  if (language === "English") {
    greeting = "Hello, ";
  } else {
    greeting = "Salut, ";
  }

  var greet = function (name) {
    // 이 함수 안에서 이름을 붙여 함수를 정의한다.
    return greeting + name;
  };

  return map(friends, greet); // 같은 범위에 있다면 이름으로 함수를 참조할 수 있다.
}
```

### 인라인으로 정의하기

함수를 사용하는 곳에서 바로 정의할 수 있다.
함수를 변수 같은 곳에 넣지 않기 때문에 이름이 없다. 그래서 익명 함수라고 부른다.
문맥에서 한 번만 쓰는 짧은 함수에 사용하면 좋다.

```js
var friendGreetings = map(friendsNames, function (name) {
  // 함수를 사용하는 곳에서 함수를 정의한다.
  return "Hello, " + name;
}); // 함수의 정의가 시작된 {와 짝을 맞추고 map() 함수를 호출하는 (와 짝을 맞춘다.
```

## 예제: 모든 고객의 이메일 주소

```js
map(customers, function (customer) {
  return customer.email;
});
```

map()을 사용하면 배열에 있는 모든 값에 함수를 적용할 수 있다.

## 함수형 도구: filter()

```js
function filter(array, f) {
  var newArray = [];
  forEach(array, function (element) {
    if (f(element)) {
      newArray.push(f(element));
    }
  });
  return newArray;
}
```

filter()는 배열에서 일부 항목을 선택하는 함수로 볼 수 있다.

```js
function selectBestCustomers(customers) {
  return filter(customers, function (customer) {
    return customer.purchases.length >= 3;
  });
}
```

## 함수형 도구: reduce()

```js
function reduce(array, init, f) {
  // 배열과 초깃값, 누적 함수를 받는다.
  var accum = init; // 누적된 값을 초기화한다.
  forEach(array, function (element) {
    accum = f(accum, element); // 누적 값을 계산하기 위해 현재 값과 배열 항목으로 f() 함수를 부른다.
  });
  return accum; // 누적된 값을 리턴한다.
}
```

reduce()는 배열을 순회하면서 값을 누적한다.

```js
function countAllPurchases(customers) {
  return reduce(customers, 0, function (total, customer) {
    return total + customer.purchases.length;
  });
}
```

> [!NOTE]
> reduce() 함수를 사용할 때 조심해야 할 또 다른 것은 초깃값을 결정하는 방법이다.
> 초깃값은 동작과 문맥에 따라 달라진다.
> 하지만 아래 두 가지 질문에 같은 답을 해야 한다.
>
> 1. **계산이 어떤 값에서 시작되는가?** 예를 들어 더하기를 한다면 초깃값은 0이어야 한다. 만약 곱하기를 해야 한다면 초깃값은 1이어야 한다.
> 2. **배열이 비어 있다면 어떤 값을 리턴할 것인가?** 위 예제에서 빈 문자열 배열을 사용한다면 합친 문자열 결과는 빈 문자열이어야 한다.

### reduce()로 할 수 있는 것들

- **실행 취소/실행 복귀**
  - 리스트 형태의 사용자 입력에 reduce()를 적용한 것이 현재 상태라고 생각해 보면, 실행 취소는 리스트의 마지막 사용자 입력을 없애는 것이라고 할 수 있다.
- **테스트할 때 사용자 입력을 다시 실행하기**
  - 시스템의 처음 상태가 초깃값이고 사용자 입력이 순서대로 리스트에 있을 때 reduce()로 모든 값을 합쳐 현재 상태를 만들 수 있다.
- **시간 여행 디버깅**
  - 어떤 언어는 변경 사항을 어떤 시점으로 되돌릴 수 있다. 뭔가 잘못 동작하는 경우 특정 시점 상태의 값을 보관할 수 있다.
- **회계 감사 추적**
  - reduce()로 과거에 어떤 일이 있었는지 기록할 수 있다. 어떤 일이 있었는지 뿐만 아니라 어떤 과정을 통해 일이 생겼는지도 알 수 있다.

### reduce()로 map()과 filter() 만들어보기

```js
function map(array, f) {
  return reduce(array, [], function (ret, item) {
    return ret.concat(f([item]));
  });
}

function map(array, f) {
  return reduce(array, [], function (ret, item) {
    ret.push(f(item));
    return ret;
  });
}

function filter(array, f) {
  return reduce(array, [], function (ret, item) {
    if (f(item)) return ret.concat([item]);
    else return ret;
  });
}

function filter(array, f) {
  return reduce(array, [], function (ret, item) {
    if (f(item)) {
      ret.push(item);
    }
    return ret;
  });
}
```
