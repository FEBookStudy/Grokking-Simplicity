소프트웨어 설계 : 코드를 만들고, 테스트하고, 유지보수하기 쉬운 프로그래밍 방법을 선택하기 위해 미적 감각을 사용하는 것

계층형 설계 : 소프트웨어를 계층으로 구성하는 기술

계층형 설계 패턴

1. 직접 구현
    - 직접 구현된 함수를 읽을 때, 함수 시그니처가 나타내고 있는 문제를 함수 본문에서 적절한 구체화 수준에서 해결해야 함
    - 오프바이원 : 주로 배열을 반복해서 처리할 때 ‘크다’ 또는 ‘크거나 같다’와 같은 비교문을 잘못 선택해 의도하지 않게 마지막 항목을 처리하지 못하거나 처리하는 오류
    - 서로 다른 추상화 단계에 있는 기능을 사용하면 직접 구현 패턴이 아님
    - 3단계 줌 레벨
        - 전역 줌 레벨(기본)
        - 계층 줌 레벨
        - 함수 줄 레벨
    - 리뷰
        - 직접 구현한 코드는 한 단계의 구체화 수준에 관한 문제만 해결
        - 계층형 설계는 특정 구체화 단계에 집중할 수 있게 도와줌
        - 호출 그래프는 구체화 단계에 대한 풍부한 단서를 보여줌
        - 함수를 추출하면 더 일반적인 함수로 만들 수 있음
        - 일반적인 함수가 많을수록 재사용하기 좋음
        - 복잡성을 감추지 않음
2. 추상화 벽
    - 호출 그래프에 어떤 계층은 중요한 세부 구현을 감추고 인터페이스를 제공함, 두뇌 용량의 한계를 극복할 수 있음
    - 팀 간 책임을 명확하게 나눔
    - 세부 구현을 감춘 함수로 이루어진 계층
    - 계층 구조에서 어떤 계층에 있는 함수들이 장바구니와 같이 공통된 개념을 신경 쓰지 않아도 된다면 그 계층을 추상화 벽이라고 할 수 있음, 추상화 벽은 필요하지 않은 것은 무시할 수 있도록 간접적인 단계를 만듦
    - ex) 추상화 벽 위에 있는 함수가 데이터 구조를 몰라도 된다는 것, 추상화 벽에 있는 함수만 사용하면 되고 장바구니 구현에 대해서는 신경 쓰지 않아도 됨
    - 사용하기 좋은 순간
        1. 쉽게 구현을 바꾸기 위해, 프로토타이핑, 서버 데이터 미정인 경우
        2. 코드를 읽고 쓰기 쉽게 만들기 위해
        3. 팀 간에 조율해야 할 것을 줄이기 위해
        4. 주어진 문제에 집중하기 위해
    - 동작
        - 추상화 단계의 상위에 있는 코드와 하위에 있는 코드는 서로 의존하지 않게 정의함
        - 추상화 단계의 모든 함수는 비슷한 세부 사항을 무시할 수 있도록 정의함
        - 추상화 벽으로 추상화를 강력하고 명시적으로 만들 수 있음
        - 마케팅 관련 코드는 장바구니가 어떻게 구현되어 있는지 몰라도 됨
3. 작은 인터페이스
    - 작고 강력한 동작으로 구성
    - 설계 감각을 키우기 위한 패턴
    - 새로운 코드를 추가할 위치에 관한 것
    - 하위 계층에 불필요한 기능이 쓸데없이 커지는 것을 막을 수 있음
4. 편리한 계층
    - 개발자의 요구를 만족시키면서 비즈니스 문제를 잘 풀 수 있어야 함, 코드와 그 코드가 속한 추상화 계층은 작업할 때 편리해야 함

호출 그래프 구조

비기능적 요구사항을 꾸밈없이 보여줌

- 기능적 요구사항 : 소프트웨어가 정확히 해야 하는 일, 세금에 대한 계산을 하면 올바른 계산 결과가 나와야 함
- 비기능적 요구사항 : 테스트를 어떻게 할 것인지, 재사용을 잘할 수 있는지, 유지보수하기 어렵지 않은지와 같은 요구사항들
1. 유지보수성 : 요구 사항이 바뀌었을 때 가장 쉽게 고칠 수 있는 코드는 어떤 코드인가요? 위로 연결된 것이 적은 함수가 바꾸기 쉬움, 자주 바뀌는 코드는 가능한 위쪽에 있어야 함
2. 테스트성 : 어떤 것을 테스트하는 것이 가장 중요한가요? 위쪽으로 많이 연결된 함수를 테스트하는 것이 더 가치 있음, 아래쪽에 있는 함수를 테스트하는 것이 위쪽에 있는 함수를 테스트하는 것이 위쪽에 있는 함수를 테스트하는 것보다 가치 있음
3. 재사용성 : 어떤 함수가 재사용하기 좋나요? 아래쪽에 함수가 적을수록 더 재사용하기 좋음, 낮은 수준의 단계로 함수를 빼내면 재사용성이 더 높아짐

그래프의 가장 위에 있는 코드가 고치기 가장 쉬움, 안정적인 코드 아래로, 테스트효과 높음
