## Chapter 6. 변경 가능한 데이터 구조를 가진 언어에서 불변성 유지하기

데이터 구조 안에 데이터 구조가 들어있는 경우 데이터가 중첩되었다고 말한다.
어떻게 하면 중첩된 데이터에 대한 불변 동작을 유지할 수 있을까?

### 동작을 읽기, 쓰기 또는 둘 다로 분류하기

동작을 읽기 또는 쓰기 또는 둘 다 하는 것으로 분류할 수 있다.

- 어떤 동작은 **읽기**이다. 읽기 동작은 데이터를 바꾸지 않고 정보를 꺼내는 것이다.
  - 만약 인자에만 의존해 정보를 가져오는 읽기 동작이라면 계산이라고 할 수 있다.
- 다른 동작은 **쓰기**이다. 쓰기 동작은 어떻게든 데이터를 바꾼다.
  - 바뀌는 값은 어디서 사용될 지 모르기 때문에 바뀌지 않도록 원칙이 필요하다.

다시 정리해보자,

**읽기**

- 데이터에서 정보를 가져온다.
- 데이터를 바꾸지 않는다.
  **쓰기**
- 데이터를 바꾼다.

읽으면서 쓰는 동작은 어떠할까? 어떤 경우에는 데이터를 바꾸면서(쓰기) 동시에 정보를 가져오는(읽기) 경우도 있다.

### 카피-온-라이트 원칙 세 단계

카피-온-라이트는 세 단계로 되어 있다. 각 단계를 구현하면 카피-온-라이트로 동작한다.

예를 들어 장바구니 전역변수를 변경하는 동작을 모두 카피-온-라이트로 바꾸면, 장바구니는 더 이상 변경되지 않는다. 따라서 불변 데이터로 동작한다.

아래 세 단계로 카피-온-라이트를 적용하면 불변성을 유지하면서 값을 바꿀 수 있다.

1. 복사본 만들기
2. 본사본 변경하기(원하는 만큼)
3. 복사본 리턴하기

우리가 기억해야할 점은 카피-온-라이트는 쓰기를 읽기로 바꾼다는 것이다.

### 쓰기를 하면서 읽기도 하는 동작은 어떻게 해야 할까

어떤 동작은 읽고 변경하는 일을 동시에 한다. 이런 동작은 값을 변경하고 리턴한다.
어떻게 해야 할까? 두 가지 접근 방법이 있다.

1. 읽기와 쓰기 함수로 각각 분리한다.
2. 함수에서 값을 두 개 리턴한다.

선택할 수 있다면 첫 번째 접근 방법이 더 좋은 방법이다.
책임이 확실히 분리되기 때문이다.

### 쓰면서 읽기도 하는 함수 분리하기

쓰면서 읽기도 하는 함수를 분리하는 작업은 두 단계로 나눌 수 있다.
먼저 쓰기에서 읽기를 분리한다.
다음으로 쓰기에 카피-온-라이트를 적용해 읽기로 바꾼다.

읽기와 쓰기를 분리하는 접근 방법은 분리된 함수를 따로 쓸 수 있기 때문에 더 좋은 방법이다.

### 불변 데이터 구조를 읽는 것은 계산이다

**변경 가능한 데이터를 읽는 것은 액션이다.**
변경 가능한 값을 읽을 때마다 다른 값을 읽을 수도 있다. 따라서 변경 가능한 데이터를 읽는 것은 액션이다.

**쓰기는 데이터를 변경 가능한 구조로 만든다.**
쓰기는 데이터를 바꾸기 때문에 데이터를 변경 가능한 구조로 만든다.

**어떤 데이터에 쓰기가 없다면 데이터는 변경 불가능한 데이터이다.**
쓰기를 모두 없앴다면 데이터는 생성 이후 바뀌지 않는다. 따라서 불변 데이터이다.

**불변 데이터 구조를 읽는 것은 계산이다.**
어떤 데이터를 불변형으로 만들었다면 그 데이터에 모든 읽기는 계산이다.

**쓰기를 읽기로 바꾸면 코드에 계산이 많아진다.**
데이터 구조를 불변형으로 만들수록 코드에 더 많은 계산이 생기고 액션은 줄어든다.

### 어플리케이션에는 시간에 따라 변하는 상태가 있다.

변경 가능한 데이터 구조를 불변 데이터로 만드는 방법을 알아봤다.
하지만 데이터가 모두 불변형이면 어플리케이션에서 시간에 따라 변하는 상태를 어떻게 다뤄야 할까?

결국 모든 값을 불변형으로 만들더라도 시간에 따라 바뀌는 값을 다룰 수 있어야 한다.
이는 **교체**를 통해 이루어진다.

### 불변 데이터 구조는 충분히 빠르다.

- 언제든지 최적화할 수 있다.
- 가비지 콜렉터는 매우 빠르다.
- 생각보다 많이 복사하지 않는다.
  - 제품이 100개인 배열을 복사해도 참조만 복사함.
  - 데이터 구조의 최상위 단계만 복사하는 것을 얕은 복사라고 함.
  - 얕은 복사는 같은 메모리를 가리키는 참조에 대한 복사본을 만든다.
  - 이를 구조적 공유라고 한다.

### 객체에 대한 카피-온-라이트

Object.assign() 메서드를 이용하여 배열에서 slice() 메서드를 이용한 것처럼 복사를 구현하자.

```js
function setPrice(item, new_price) {
  var item_copy = Object.assign({}, item);
  item_copy.price = new_price;
  return item_copy;
}
```

> **얕은 복사**
> 얕은 복사는 중첩된 데이터 구조에 최상위 데이터만 복사한다. 예를 들어 객체가 들어있는 배열이 있다면 얕은 복사는 배열만 복사하고 안에 있는 객체는 참조로 공유한다.
> 두개의 중첩된 데이터 구조가 어떤 참조를 공유한다면 **구조적 공유**라고 한다. 데이터가 바뀌지 않는 불변 데이터 구조라면 구조적 공유는 안전하다. 구조적 공유는 메모리를 적게 사용하고, 모든 것을 복사하는 것보다 빠르다.

### 중첩된 쓰기를 읽기로 바꾸기

중첩된 쓰기도 중첩되지 않은 쓰기와 같은 패턴을 사용한다.
복사본을 만들고 변경한 다음 복사본을 리턴한다. 중첩된 항목에 또 다른 카피-온-라이트를 사용하는 부분만 다르다.

원래의 항목을 직접 변경하면 불변 데이터가 아니다. 배열의 항목은 바뀌지 않지만 배열 항목이 참조하는 값은 바뀐다. 이렇게 되면 불변 데이터가 아니다. 중첩된 모든 데이터 구조가 바뀌지 않아야 불변 데이터라고 할 수 있다.

이는 매우 중요한 개념이다. 최하위부터 최상위까지 중첩된 데이터 구조의 모든 부분이 불변형이어야한다.
중첩된 데이터의 일부를 바꾸려면 변경하려는 값과 상위의 모든 값을 복사해야 한다.

### 결론과 요점 정리

- 함수형 프로그래밍에서는 불변 데이터가 필요하다. 계산에서는 변경 가능한 데이터에 쓰기를 할 수 없다.
- 카피-온-라이트는 데이터를 불변형으로 유지할 수 있는 원칙이다. 복사본을 만들고 원본 대신 복사본을 변경하는 것을 말한다.
- 카피-온-라이트는 값을 변경하기 전에 얕은 복사를 한다. 그리고 리턴한다. 이렇게 하면 통제할 수 있는 범위에서 불변성을 구현할 수 있다.

### 논의 사항

우리는 그동안 **얕은 복사**를 이용한 **구조적 공유**에 대한 것을 생각하며 코드를 짰던 적이 있는가?

---

## Chapter 7. 신뢰할 수 없는 코드를 쓰면서 불변성 지키기

카피-온-라이트를 적용할 수 없는 코드를 함께 사용해야 할 때가 있다.
바꿀 수 없는 라이브러리나 레거시 코드가 데이터를 변경한다면 카피-온-라이트를 적용할 수 없다.

어떻게 이런 코드에 불변 데이터를 전달할 수 있을까?
데이터를 변경하는 코드를 함깨 사용하면서 불변성을 지키는 방법에 대해 알아보자.

### 우리가 만든 카피-온-라이트 코드는 신뢰할 수 없는 코드와 상호작용해야 한다.

- 카피-온-라이트가 적용된 안전지대 코드는 걱정없이 쓸 수 있다.
- 안전지대 밖에 있는 코드 및 함수와 안전지대에 있는 코드와 데이터를 주고 받아야한다.

여기서 문제가 발생하는 것은 다음과 같다.

- 안전지대 밖으로 나가는 데이터는 잠재적으로 바뀔 수 있다.
- 마찬가지로 신뢰할 수 없는 코드에서 안전지대로 들어오는 데이터 역시 잠재적으로 바뀔 수 있다.
  - 신뢰할 수 없는 코드가 계속 데이터 참조를 가지고 있기 때문에 언제든 바뀔 수 있다.

우리는 불변성을 지키면서 데이터를 주고받는 방법을 찾아야 한다.
이는 우리가 알고 있는 카피-온-라이트 패턴으로 해결할 수 없다.
카피-온-라이트 패턴은 데이터를 바꾸기 전에 복사한다.
이는 무엇이 바뀌는지 알기 때문에 무엇을 복사할 지 예상할 수 있는 것이다.
반면, 분석하기 힘든 레거시 코드는 어떤 일이 일어날지 정확히 알 수 없다.

따라서, 데이터가 바뀌는 것을 완벽히 막아주는 원칙이 필요하다.
이 원칙을 **방어적 복사**라고 한다.

### 방어적 복사는 원본이 바뀌는 것을 막아준다.

신뢰할 수 없는 코드와 데이터를 주고받는 문제를 푸는 방법은 복사본을 만드는 것이다.

1. 바뀔 수도 있는 데이터가 신뢰할 수 없는 코드에서 안전지대로 들어온다.
2. 들어온 데이터로 깊은 복사본을 만들고 변경 가능한 원본은 버린다.
3. 신뢰할 수 있는 코드만 복사본을 쓰기 때문에 데이터는 바뀌지 않는다.

이런 방법으로 들어오는 데이터를 보호할 수 있다.

안전지대에서 나가는 데이터도 바뀌면 안된다.
안전지대 밖으로 나가는 데이터는 신뢰할 수 없는 코드가 값을 변경할 수 있어서 변경하지 못하도록 해야 한다.
그렇게 하려면 나가는 데이터도 깊은 복사본을 만들어 내보내면 된다.
이렇게 하면 나가는 데이터를 보호할 수 있다.

결론적으로, 들어오고 나가는 데이터의 복사본을 만드는 것이 방어적 복사가 동작하는 방식이다.
안전지대에 불변성을 유지하고, 바뀔 수도 있는 데이터가 안전지대로 들어오지 못하도록 하는 것이 방어적 복사의목적이다.

### 방어적 복사 구현하기

인자로 들어온 값이 변경될 수도 있는 함수를 사용하면서 불변성은 지켜야 한다.
**방어적 복사**를 사용하면 데이터가 바뀌는 것을 막아 불변성을 지킬 수 있다.

복사본을 직접 만들어 데이터를 보호하고 데이터가 시스템에서 나가기 전에 복사하고 들어올 때도 복사한다.
또한 복사할 때는 **깊은 복사**를 해야 한다.

### 방어적 복사 규칙

1. 데이터가 안전한 코드에서 나갈 때 복사하기
   1. 불변성 데이터를 위한 깊은 복사본을 만든다.
   2. 신뢰할 수 없는 코드로 복사본을 전달한다.
2. 안전한 코드로 데이터가 들어올 때 복사하기
   1. 변경될 수도 있는 데이터가 들어오면 바로 깊은 복사본을 만들어 안전한 코드로 전달한다.
   2. 복사본을 안전한 코드에서 사용한다.

이러한 규칙을 따르면 불변성 원칙을 지키면서 신뢰할 수 없는 코드와 상호작용할 수 있다.
첫 번째 규칙과 두 번째 규칙은 순서에 관계없이 쓸 수 있다.

### 생각보다 익숙할지도 모르는 방어적 복사

방어적 복사는 오래전부터 다른 곳에서 쓰던 일반적인 패턴이다.
대부분의 웹 기반 API는 암묵적으로 방어적 복사를 한다.
API 통신에서 JSON 데이터를 이용하는 것도 깊은 복사를 이용하는 방법이다.

### 카피-온-라이트와 방어적 복사는 비슷한 것 같다?

카피-온-라이트와 방어적 복사 모두 불변성을 유지하기 위해 사용한다.
어떻게 보면 하나만 있어도 될 것 같다. 사실 안전지대에서도 방어적 복사로 불변성을 유지할 수 있다.

하지만 방어적 복사는 깊은 복사를 한다. 깊은 복사는 위에서 아래로 모든 계층의 중첩된 데이터를 복사하기 때문에 얕은 복사보다 더 많은 비용이 든다.
많은 복사본 때문에 연산과 메모리를 낭비하는 것을 막으려면 가능한 안전지대에서는 카피-온-라이트를 사용하는 것이 좋다. 결국 두 원칙은 함께 사용해야 하는 것이다.

### 카피-온-라이트와 방어적 복사를 비교해보자

**카피-온-라이트**

1. 언제 쓰는가?
   - 통제할 수 있는 데이터를 바꿀 때 카피-온-라이트를 쓴다.
2. 어디서 쓰는가?
   - 안전지대 어디서나 쓸 수 있다. 사실 카피-온-라이트가 불변성을 가진 안전지대를 만든다.
3. 복사 방식
   - 얕은 복사(상대적으로 비용이 적게 든다)
4. 규칙
   1. 바꿀 데이터의 얕은 복사를 만든다.
   2. 복사본을 변경한다.
   3. 복사본을 리턴한다.

**방어적 복사**

1. 언제 쓰는가?
   - 신뢰할 수 없는 코드와 데이터를 주고받아야 할 때 방어적 복사를 쓴다.
2. 어디서 쓰는가?
   - 안전지대의 경계에서 데이터가 오고 갈 때 방어적 복사를 쓴다.
3. 복사 방식
   - 깊은 복사(상대적으로 비용이 많이 든다)
4. 규칙
   1. 안전 지대로 들어오는 데이터에 깊은 복사를 만든다.
   2. 안전지대에서 나가는 데이터에 깊은 복사를 만든다.

### 깊은 복사는 얕은 복사보다 비싸다

깊은 복사는 원본과 어떤 데이터 구조도 공유하지 않는 것이 얕은 복사와의 차이점이다.
중첩된 모든 객체나 배열을 복사한다. 얕은 복사에서는 바뀌지 않은 값이라면 원본과 복사본이 데이터를 공유한다.

깊은 복사는 확실히 바싸다, 따라서 모든 곳에 쓰는 것이 아니다.
카피-온-라이트를 사용할 수 없는 곳에서만 사용한다.

### 결론과 요점 정리

불변성을 유지할 수 있는 강력하고 더 일반적인 원칙인 **방어적 복사**.
불변성을 스스로 구현할 수 있기 때문에 더 강력하다. 하지만 더 많은 데이터를 복사해야하므로 비용이 많이 든다.
따라서 카피-온-라이트와 함께 적절히 둘을 섞어서 사용하도록 해야한다.

- 방어적 복사는 불변성을 구현하는 원칙이다. 데이터가 들어오고 나갈 때 복사본을 만든다.
- 방어적 복사는 깊은 복사를 한다. 그래서 카피-온-라이트보다 비용이 더 든다.
- 카피-온-라이트와 다르게 방어적 복사는 불변성 원칙을 구현하지 않는 코드로부터 데이터를 보호해준다.
- 복사본이 많이 필요하지 않기 때문에 카피-온-라이트를 더 많이 사용한다. 방어적 복사는 신뢰할 수 없는 코드와 함께 사용할 때만 사용한다.
- 깊은 복사는 위에서 아래로 중첩된 데이터 전체를 복사한다. 얕은 복사는 필요한 부분만 최소한으로 복사한다.

### 논의 사항

- 책에서 JSON 데이터를 사용해서 깊은 복사를 했다고 나와있었는데, JSON 이외의 깊은 복사를 사용한 경험이 있는가?
- 리팩토링 해나가는 방식이 아닌, 처음부터 안전지대를 잘 설계하고 코드를 짤 수 있는 팁은 무엇일까?
