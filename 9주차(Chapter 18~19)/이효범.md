## Chapter 18. 반응형 아키텍처와 어니언 아키텍처

### 반응형 아키텍처
- 애플리케이션 구조화하는 방법

핵심 원칙은 **이벤트에 대한 반응으로 일어날 일을 지정**하는 것.
- 웹 서비스와 UI에 잘 어울림.

웹 서비스는 웹 요청 응답에 일어날 일을 지정하고, UI는 버튼 클릭과 같은 이벤트 응답에 일어날 일을 지정한다.
- 이를 일반적으로 이벤트 핸들러라고 한다.
- X가 일어나면 언제나 Y를 한다.

**언제** 사용하고 **어떻게** 사용할 지 판단은 우리들의 몫이다.

---

### 셀은 일급 상태입니다.

```js
function ValueCell(initialValue) {
	var currentValue = initialValue; // 변경 불가능한 값 하나 담아두기
	return {
		val: function() { // 현재 값을 가져오기
			return currentValue;
		},
		update: function(f) { // 현재 값에 함수를 적용해 값을 바꾸기 (교체 패턴)
			var oldValue = currentValue;
			var newValue = f(oldValue);
			currentValue = newValue;
		}
	}
}
```

- `ValueCell` 에는 값 하나와 두 개의 동작이 있다.
	- 값을 읽는 동작
	- 현재 값을 바꾸는 동작

### ValueCell을 반응형으로 만들 수 있습니다.
- 감시자 개념을 추가해보자.
- `감시자 === 옵저버`

```js
function ValueCell(initialValue) {
	var currentValue = initialValue; // 변경 불가능한 값 하나 담아두기
	var watchers = [];
	return {
		val: function() { // 현재 값을 가져오기
			return currentValue;
		},
		update: function(f) { // 현재 값에 함수를 적용해 값을 바꾸기 (교체 패턴)
			var oldValue = currentValue;
			var newValue = f(oldValue);
			if (oldValue !== newValue) {
				currentValue = newValue;	
				forEach(watchers, function(watcher) {
					watcher(newValue);
				});
			}
		},
		addWatcher: function(f) {
			watchers.push(f);
		}
	}
}
```


### FormulaCell은 파생된 값을 계산합니다.

```js
function FormulaCell(upstreamCell, f) {
	var myCell = ValueCell(f(upstreamCell.val()));
	upstreamCell.addWatcher(function(newUpstreamValue)) {
		myCell.update(function(currentValue)) {
			return f(newUpstreamValue);
		};
	};
	return {
		val: myCell.val,
		addWatcher: myCell.addWatcher
	}
}
```
- `FormulaCell` 은 값을 직접 바꿀 수 없다.
- 감시하던 상위 셀 값이 바뀌면 `FormulaCell` 값이 바뀐다.
- 상위 셀이 바뀌면 상위 값을 가지고 셀 값을 다시 계산한다.
- `FormulaCell`에는 값을 바꾸는 기능은 없지만 `FormulaCell`을 감시할 수 있다.

---
### 함수형 프로그래밍과 변경 가능한 상태
함수형 개발자는 어떻게 해서든지 변경 가능한 상태를 사용하지 않는다?

함수형 프로그래밍을 비롯해 모든 소프트웨어는 변경 가능한 상태를 잘 관리해야한다.

- 셀은 변경할 수 있지만 변경 불가능한 변수에 값을 담아두기 때문에 전역변수보다 더 안전하다.
- `ValueCell`의 `update()` 메서드를 사용하면 현재 값을 항상 올바르게 유지할 수 있다.
- 왜 그럴까? `update()`를 사용할 때 계산을 넘기기 때문이다.

많은 함수형 언어나 프레임워크에는 `ValueCell`과 같은 것들이 있다.
- 리액트: Redux store와 Recoil atom

---

### 반응형 아키텍처를 사용해야 하는 상황

반응형 아키텍처는 원인과 효과의 중심을 관리해야 한다.
- 순차적인 단계가 있고 항상 원인이 하나라면, 여기에는 더 직관적인 순차적 액션이 좋다.
- 여러 원인이 있고 그에 따른 여러 효과가 있다면, 반응형 아키텍처는 원인과 효과를 분리하기 때문에 해야할 일을 독립적으로 처리할 수 있기 때문에 반응형 아키텍처를 사용하기 좋다.

---

### 어니언 아키텍처는 무엇인가요?
어니언 아키텍처는 현실 세계와 상호작용하기 위한 서비스 구조를 만드는 방법이다. 이름에서 알 수 있듯이 둥글게 겹겹이 쌓인 양파 모양을 하고 있다.


- 인터랙션 계층
	- 바깥세상에 영향을 주거나 받는 액션
- 도메인 계층
	- 비즈니스 규칙을 정의하는 게산
- 언어 계층
	- 언어 유틸리티와 라이브러리

어니언 아키텍처는 특정 계층이 꼭 필요하다고 강제하지 않는다.
하지만 많은 경우에 위와 같이 3가지 큰 분류로 나눌 수 있다.

1. 현실 세계와 상호작용은 인터랙션 계층에서 해야 한다.
2. 계층에서 호출하는 방향은 중심 방향이다.
3. 계층은 외부에 어떤 게층이 있는지 모른다.

**데이터**
데이터는 이벤트에 대한 사실이다. 숫자나 문자열, 컬렉션 같은 것들이 데이터이다. 데이터는 수동적이고 투명하다.

**계산**
계산은 입력으로 출력을 만드는 연산이다. 같은 입력을 주면 항상 같은 결과를 낸다. 계산은 호출 시점이나 횟수에 영향을 받지 않는다. 실행 순서가 중요하지 않기 때문에 타임라인에 표시하지 않는다.

**액션**
액션은 바깥 세계에 영향을 주거나 받는 실행 가능한 코드이다. 따라서 호출 시점에 횟수가 중요하다. 데이터베이스나 API, 웹 요청과 상호작용하는 것은 모두 액션이다.


### 전통적인 계층형 아키텍처
전통적인 아키텍처로 웹 API를 만들 때 계층이라고 하는 개념을 사용한다. 하지만 어니언 아키텍처의 계층과는 다르다. 다음은 웹 서버를 만들 때 사용하는 전형적인 계층이다.

1. 웹 인터페이스 계층
	1. 웹 요청을 도메인으로 바꾸고 도메인을 웹 응답으로 바꾼다.
2. 도메인 계층
	1. 애플리케이션 핵심 로직으로 도메인 개념에 DB 쿼리나 명령이 들어간다.
3. 데이터베이스 계층
	1. 시간에 따라 바뀌는 정보를 저장한다.

전통적인 계층형 아키텍처는 데이터베이스를 기반으로 한다. 도메인 계층은 데이터베이스 동작으로 만든다. 그리고 웹 인터페이스는 웹 요청을 도메인 동작으로 변환한다.

데이터베이스 계층이 가장 아래 있다면 그 위에 있는 모든 것이 액션이 되기 때문에 함수형 스타일이 아니다. 모든 것이 계층에 쌓여있고 계산은 따로 관리되지 않고 우연히 사용된다. 함수형 아키텍처는 계산과 액션에 대한 명확한 규칙이 있어야 한다.

### 함수형 아키텍처
함수형 아키텍처는 도메인 계층이 데이터베이스 계층에 의존하지 않는다.
데이터베이스 동작은 값을 바꾸거나 데이터베이스에 접근하기 때문에 액션이다.

데이터베이스는 변경 가능하고 접근하는 모든 것을 액션으로 만든다는 것이 핵심이다.
그래서 도메인 동작을 포함해 그래프에 가장 위에 있는 것까지 모두 액션이 된다.

함수형 개발자는 액션과 계산을 명확하게 구분하려고 하고 도메인 로직은 모두 계산으로 만들어야 한다고 생각한다.
따라서 데이터베이스를 도메인과 분리하는 것이 중요하다.

가장 위에 있는 액션에서 도메인 규칙과 데이터베이스를 조합한다.

**어니언 아키텍처 규칙**
1. 현실 세계와 상호작용은 인터랙션 계층에서 해야한다.
2. 계층에서 호출하는 방향은 중심 방향이다.
3. 계층은 외부에 어떤 계층이 있는지 모른다.

### 변경과 재사용이 쉬워야한다.
어니언 아키텍처는 인터랙션 계층을 바꾸기 쉽다. 인터랙션 계층은 가장 위에 있어서 가장 바꾸기 쉽다. 도메인이 데이터베이스나 웹 요청에 의존하지 않기 때문에 인터랙션 계층에 속하는 데이터베이스나 서비스 프로토콜은 쉽게 바꿀 수 있다. 그리고 도메인 계층도 데이터베이스나 서비스 같은 것을 사용하지 않으므로 전부 계산으로 만들 수 있다.

다시 정리해보자, 어니언 아키텍처는 데이터베이스나 API 호출과 같은 외부 서비스를 바꾸기 쉽다. 가장 높은 계층에서 사용하기 때뭉니다. 도메인 계층은 외부 서비스에 의존하지 않아서 테스트하기 좋다. 어니언 아키텍처는 좋은 인프라보다 좋은 도메인을 강조한다.

### 도메인 구칙은 도메인 용어를 사용한다.
프로그램의 핵심 로직은 **도메인 규칙** 또는 **비즈니스 규칙**이라고 한다.
모든 로직이 도메인 규칙이 아니므로 어떤 로직이 도메인 규칙인지 판단하기 위해 코드에 나타나는 용어를 참고할 수 있다. 


---

**결론**
<br />
반응형 아키텍처는 액션에 반응할 다른 액션을 지정해 순차적 액션의 순서를 바꾼다.
어니언 아키텍처는 함수형 사고를 적용한다면 자연스럽게 따라오는 아키텍처이다.





