## Chapter 8. 계층형 설계 
이 책에서 다루려고 하는 **소프트웨어 설계**의 실용적인 정의는 다음과 같다.

**소프트웨어 설계**
- 코드를 만들고, 테스트하고, 유지보수하기 쉬운 프로그래밍 방법을 선택하기 위해 미적 감각을 사용하는 것

이번 챕터에서는 **계층형 설계**를 사용해 소프트웨어 설계를 위한 미적 감각을 키워보자.

---
## 계층형 설계란 무엇인가요?
**계층형 설계는 소프트웨어를 계층으로 구성하는 기술**이다.
각 계층에 있는 함수는 바로 아래 계층에 있는 함수를 이용해 정의합니다.

```
비즈니스 규칙 (cart_tax() 등)
👇
장바구니를 위한 동작들 (add_item() 등)
👇
카피-온-라이트 (add_element_last() 등)
👇
언어에서 지원하는 배열 관련 기능 (.slice() 등)
```

**계층을 잘 구분하려면 구분하기 위한 다양한 변수를 찾고,**
**찾은 것을 가지고 어떻게 해야 하는지 알아야 한다.**

이는 처음부터 쉬운 것은 아니다.

"가장 좋은 설계"를 위한 절대 공식과 그 공식을 만드는 변수는 많이 있지만 복잡하게 섞여 있어 찾기 어렵다.
하지만 좋은 설계를 위한 감각을 개발하고 그 감각을 따라가다보면 찾을 수 있다.

그렇다면 좋은 설계를 위한 감각은 어떻게 키울 수 있을까?

> **계층형 설계**
> 소프트웨어를 계층으로 구성하는 기술.

**계층형 설계 감각을 키우기 위한 ==입력==**
1. 함수 본문
	1. 길이
	2. 복잡성
	3. 구체화 단계
	4. 함수 호출
	5. 프로그래밍 언어의 기능 사용
2. 계층 구조
	1. 화살표 길이
	2. 응집도
	3. 구체화 단계
3. 함수 시그니처
	1. 함수명
	2. 인자 이름
	3. 인잣값
	4. 리턴값
**계층형 설계 감각을 키우기 위한 ==출력==**
1. 조직화
	1. 새로운 함수를 어디에 놓을 지 결정
	2. 함수를 다른 곳으로 이동
2. 구현
	1. 구현 바꾸기
	2. 함수 추출하기
	3. 데이터 구조 바꾸기
3. 변경
	1. 새 코드를 작성할 곳 선택하기
	2. 적절한 수준의 구체화 단계 결정하기

---
## 계층형 설계 패턴
여러 방향으로 계층형 설계에 대해 살펴볼 수 있지만, 그중 가장 중요한 네가지 패턴을 살펴보자.

1. **패턴 1: 직접 구현**
	- 직접 구현은 계층형 설계 구조를 만드는 데 도움이 된다. 직접 구현된 함수를 읽을 때, 함수 시그니처가 나타내고 있는 문제를 함수 본문에서 적절한 구체화 수준에서 해결해야 한다.
1. **패턴 2: 추상화 벽**
	- 호출 그래프에 **어떤 계층은 중요한 세부 구현을 감추고 인터페이스를 제공**한다. 인터페이스를 사용하여 코드를 만들면 높은 차원으로 생각할 수 있다. 고수준의 추상화 단계만 생각하면 되기 때문에 두뇌 용량의 한계를 극복할 수 있다.
2. **패턴 3: 작은 인터페이스**
	- **시스템이 커질수록** 비즈니스 개념을 나타내는 중요한 인터페이스는 작고 강력한 동작으로 구성하는 것이 좋다. 다른 동작도 직간접적으로 최소한의 인터페이스를 유지하면서 정의해야 한다.
3. **패턴 4: 편리한 계층**
	- 계층형 설계 패턴과 실천 방법은 개발자의 요구를 만족시키면서 **비즈니스 문제를 잘 풀 수 있어야** 한다. 소프트웨어를 더 빠르고 고품질로 제공하는 데 도움이 되는 계층에 시간을 투자해야 한다. 그냥 좋아서 계층을 추가하면 안된다. 코드와 그 코드가 속한 추상화 계층은 작업할 때 편리해야 한다.

---
## 패턴 1: 직접 구현
어떻게 하면 구현된 코드를 잘 읽을 수 있을까?
계층 구조는 아무리 강력한 기능을 하는 함수가 있더라도 복잡하지 않게 함수를 표현해야 한다.

```js
function freeTieClip(cart) {
	var hasTie = false;
	var hasTieClip = false;
	for(var i = 0; i < cart.length; i++) {
		var item = cart[i];
		if(item.name === 'tie') { // 넥타이가 있는지 확인
			hasTie = true;
		}
		if(item.name === 'tie clip') { // 넥타이 클립이 있는지 확인
			hasTieClip = true;
		} 
	}
	if(hasTie && !hasTieClip) {
		var tieClip = make_item("tie clip", 0);
		return add_item(cart, tieClip); // 넥타이 클립 추가
	}
	return cart;
}
```

어렵지 않은 코드이지만, 많은 기능이 있다. 장바구니를 돌면서 항목을 체크하고 무엇인가를 결정하고 있다.
이 코드는 제대로 설계하지 않고 그냥 기능을 추가한 것이다. 어떠한 설계 원칙을 가지고 설계하지 않았다.
이렇게 코드를 바로 추가하면 유지보수하기 어렵다.

==이 코드는 첫 번째 계층형 설계 패턴인 직접 구현을 따르지 않고 있다.==
freeTieClip() 함수가 알아야 할 필요가 없는 구체적인 내용을 담고 있다.

**장바구니가 해야할 동작**
설계를 개선하기 위해, 장바구니가 해야 할 동작을 정리해보기로 한다.
습관적으로 코드를 바로 작성하는 대신 해볼 수 있는 방법이다.

장바구니에 필요한 동작은 아래와 같다.
1. 제품 추가하기
2. 제품 삭제하기
3. 장바구니에 제품이 있는지 확인하기
4. 합계 계산하기
5. 장바구니 비우기
6. 제품 이름으로 가격 설정하기
7. 세금 계산하기
8. 무료 배송이 되는지 확인하기

**제품이 있는지 확인하는 함수가 있다면 설계를 개선할 수 있다.**
장바구니가 해야 할 동작을 모두 정리해보니 개선할 수 있는 부분을 발견했다.
freeTieClip() 함수에 직접 구현 패턴을 적용할 수 있을 것 같다.

> 장바구니 안에 제품이 있는지 확인하는 함수를 만들면 freeTieClip()을 더 명확하게 할 수 있을 것 같다.

즉, 장바구니 안에 제품이 있는지 확인하는 함수가 있다면, freeTieClip() 내에서 저수준의 반복문을 직접 쓰지 않을 수 있다.
저수준의 코드는 추출해야 할 가능성이 높다. 

```js
function isInCart(cart, name) {
	for(var i = 0; i < cart.length; i++) {
		if (cart[i].name === name) { 
			return true;
		}
	}
	return false;
}
```

==개선한 함수는 짧고 명확하다.== 또 모두 비슷한 구체화 수준에서 작동하고 있기 때문에 읽기 쉽다.


**호출 그래프를 만들어 함수 호출을 시각화하기**
freeTieClip 내부에서 함수 호출과 언어 기능을 호출 하는 부분을 시각화해보자.
직접 만든 함수와 언어 기능은 추상화 수준이 다르다.
예를 들어 반목문과 배열 인덱스를 참조하는 기능은 더 낮은 추상화 단계이다.
==한 함수에서 서로 다른 추상화 단계를 사용하면 코드가 명확하지 않아 읽기 어려울 수 있다.==


**직접 구현 패턴을 사용하면 비슷한 추상화 계층에 있는 함수를 호출한다.**
서로 다른 추상화 단계에 있는 기능을 사용하면 직접 구현 패턴이 아니다.
개선된 freeTieClip() 함수는 더 가까운 추상화 계층을 호출할 수 있게 된다.

```js
function freeTieClip(cart) {
	var hasTie = isInCart(cart, "tie");
	var hasTieClip = isInCart(cart, "tie clip");
	if (hasTie && !hasTieClip) {
		var tieClip = make_item("tie clip", 0);
		return add_item(cart, tieClip);
	}
	return cart;
}
```

개선된 freeTieClip() 함수를 살펴보자.
freeTieClip() 내부에 있는 함수들이 정확히 같은 추상화 단계인지 확실할 수 없지만 비슷한 추상화 단계를 사용하고 있는 것 같아 보인다.
조금 명확하지 않지만 괜찮다. 뒤에서 명확하게 하기 위해 다른 각도로 살펴볼 것이다.
지금은 freeTieClip() 함수가 장바구니 기능을 사용하기 위해 알아야 할 것이 무엇인지에 집중해 보자.
개선된 freeTieClip()은 장바구니가 배열로 되어 있는지 알아야 할까? 

개선된 함수에서는 장바구니가 배열인지 몰라도 된다. freeTieClip()이 사용하는 모든 함수는 장바구니가 배열인지 몰라도 된다. 
==장바구니가 배열인지 몰라도 된다는 것은 함수가 모두 비슷한 계층에 있는다는 것을 의미한다.==

> **이처럼 함수가 모두 비슷한 계층에 있다면 직접 구현했다고 할 수 있다.**

> **함수 이름은 함수가 어느 곳에 위치할 지 결정하기 위한 정보로 쓸 수 있다.**


**같은 계층에 있는 함수는 같은 목적을 가져야 한다**.
함수를 어떤 계층에 놓을지 선택하는 과정은 복잡하다. 그래도 계층이 서로 구분되는 목적이 있다면, 함수가 위치할 계층을 선택하는 데 좋은 정보로 사용할 수 있다. 계층의 목적은 각 계층에 있는 함수의 목적과 같다.

예를 들어 책에서는,
```
장바구니 비즈니스 규칙 
👇
일반적인 비즈니스 규칙
👇
장바구니 기본 동작
👇
제품에 대한 기본 동작
👇
카피-온-라이트 동작
👇
자바스크립트 언어 기능
```

각 계층은 추상화 수준이 다르다. 그래서 어떤 계층에 있는 함수를 읽거나 고칠 때 낮은 수준의 구체적인 내용은 신경쓰지 않아도 된다. 
예를 들어 '장바구니 비즈니스 규칙' 계층에 있는 함수를 쓸 때, 장바구니가 배열로 구현되어 있다는 것과 같은 구체적인 내용은 신경 쓰지 않아도 된다.

==직접 구현이 어떻게 계층형 설계에 도움이 될까?==

---
## 3단계 줌 레벨
계층형 설계에서 문제는 세 가지 다른 영역에서 찾을 수 있다.

1. 계층 사이에 상호 관계
2. 특정 계층의 구현
3. 특정 함수의 구현

문제를 찾기 위해 알맞은 줌 레벨을 사용해 하나의 영역을 살펴볼 수 있다.

### 1. 전역 줌 레벨
전역 줌 레벨로 그래프 전체 중 필요한 부분을 살펴볼 수 있다.
즉, 전역 줌 레벨이 기본 줌 레벨이다. 계층 사이에 상호 관계를 포함해서 모든 문제를 살펴볼 수 있다.

### 2. 계층 줌 레벨
계층 줌 레벨은 한 계층과 연결된 바로 아래 계층을 볼 수 있는 줌 레벨이다.
계층 줌 레벨로 계층이 어떻게 구현되어 있는지 알 수 있다.

### 3. 함수 줌 레벨
함수 줌 레벨로 함수 하나와 바로 아래 연결된 함수들을 볼 수 있다.
함수 줌 레벨로 함수 구현의 문제를 찾을 수 있다.

---

**계층 줌 레벨로 보면 함수가 가리키는 화살표를 계층 간에 비교할 수 있다.**
직접 구현 패턴을 사용하면 모든 화살표가 다이어그램 내에서 같은 길이를 가져야 한다.
이는 코드가 정돈되어 있지 않기 때문이다. 이러한 복잡함을 정리하기 위한 방법을 찾아야 한다.

**함수 줌 레벨을 사용하면 함수 하나가 가진 화살표를 비교할 수 있다.**
하나의 함수에 집중하면 함수가 가리키는 화살표를 모두 볼 수 있다.
함수 자신과 함수가 사용하는 언어 기능 그리고 다른 함수를 바라보도록 하자.

예를 들어 remove_item_by_name() 함수만 봐도, 서로 다른 계층의 동작을 사용하는 것을 확인할 수 있다.
이것은 직접 구현 패턴에 맞지 않는다.

직접 구현 패턴을 적용하면 remove_item_by_name()가 모두 같은 길이의 화살표를 가져야 한다.
어떻게 하면 화살표를 같은 길이로 만들 수 있을까?

==가장 일반적인 방법은 중간에 함수를 두는 것이다.==
언어 기능을 사용하는 긴 화살표를 줄여야 한다.

---

## 반복문 빼내기
remove_item_by_name() 함수에서 반복문을 빼서 새로운 함수로 만들어 보자.
현재 remove_item_by_name() 내의 반복문은 배열 안에 항목을 순서대로 확인해서 조건에 맞는 항목의 인덱스를 찾는다. 
이러한 로직을 따로 빼낸 indexOfItem()이라는 함수로 만들어 보자.

```js
function indexOfItem(cart, name) {
	for (var i = 0; i < cart.length; i++) {
		if (cart[i].name === name) {
			return i;
		}
	}
	return null;
}
```


---

```js
function isInCart(cart, name) {
	for(var i = 0; i < cart.length; i++) {
		if (cart[i].name === name) { 
			return true;
		}
	}
	return false;
}
```

```js
function indexOfItem(cart, name) {
	for (var i = 0; i < cart.length; i++) {
		if (cart[i].name === name) {
			return i;
		}
	}
	return null;
}
```

위의 isInCart() 함수와 indexOfItem() 함수는 비슷하게 생겼다.
비슷한 부분을 함께 쓸 수 있을까? 어떤 함수에서 다른 쪽 함수를 가져다 쓸 수 있을까?

==indexOfItem() 함수가 isInCart() 함수보다 더 낮은 수준의 함수이다.==

indexOfItem() 함수는 인덱스를 리턴하기 때문에 사용하는 곳에서 장바구니가 배열이라는 것을 알아야 한다.
반면, isInCart() 함수는 불리언값을 리턴하기 때문에 사용하는 곳에서 장바구니가 어떤 구조인지 몰라도 된다.

indexOfItem() 함수가 isInCart() 함수보다 더 낮은 수준에 있기 때문에 indexOfItem() 함수를 사용해 isInCart() 함수를 새롭게 만들 수 있다.

```js
function isInCart(cart, name) {
	return indexOfItem(cart, name) !== null;
}
```

재사용으로 코드가 더 짧아졌고 계층도 명확해지는 장점을 모두 얻었다.

---

## 직접 구현 패턴 리뷰
- 직접 구현한 코드는 한 단계의 구체화 수준에 관한 문제만 해결한다.
	- 직접 구현한 코드는 읽기 위해 알아야 하는 구체화 단계의 범위를 줄여준다.
- 계층형 설계는 특정 구체화 단계에 집중할 수 있게 도와준다.
- 호출 그래프는 구체화 단계에 대한 풍부한 단서를 보여준다.
	- 호출 그래프는 함수가 서로 연결되어 있는지 보여준다.
- 함수를 추출하면 더 일반적인 함수로 만들 수 있다.
	- 함수에 직접 구현 패턴을 적용하는 방법의 하나는 함수가 더 구체적인 내용을 다루지 않도록 함수를 일반적인 함수로 빼내는 것이다. 일반적인 함수는 보통 구체적인 내용을 하나만 다루기 때문에 테스트하기 쉽다. 명확한 코드와 알맞은 이름을 가진 함수는 더 읽기 쉽다.
- 일반적인 함수가 많을수록 재사용하기 좋다.
	- 구현을 명확하게 하기 위해 일반적인 함수를 빼낸다. 일반적인 함수는 구체적인 함수보다 더 많은 곳에서 쓸 수 있다.
- 복잡성을 감추지 않는다.
	- 계층형 설계에서 모든 계층은 바로 아래 계층에 의존해야 한다. 더 낮은 구체화 수준을 가진 일반적인 함수를 만들어 소프트웨어에 직접 구현 패턴을 적용해야 한다.

## 결론
계층 간 차이를 보기 위해 호출 그래프를 그려 코드를 시각화했다.
그리고 계층형 설계에서 가장 중요한 첫 번째 패턴인 직접 구현 패턴을 알아봤다.

직접 구현 패턴이 적용된 계층 구조로 만들면, 간단한 함수로 또 다른 간단한 함수를 만들면서 코드를 구성할 수 있다.
하지만 계층형 설계를 잘 만드는 방법은 더 있다. 다음 챕터에서 남은 세 개의 패턴을 살펴보자.


## 요점 정리
- 계층형 설계는 코드를 추상화 계층으로 구성한다. 각 계층을 볼 때 다른 계층에 구체적인 내용을 몰라도 된다.
- 문제 해결을 위한 함수를 구현할 때 어떤 구체화 단계로 쓸지 결정하는 것이 중요하다. 그래야 함수가 어떤 계층에 속할지 알 수 있다.
- 함수가 어떤 계층에 속할지 알려주는 요소는 많이 있다. 함수 이름과 본문, 호출 그래프 등이 그런 요소이다.
- 함수 이름은 의도를 알려준다. 비슷한 목적의 이름을 가진 함수를 함께 묶을 수 있다.
- 함수 본문은 중요한 세부 사항을 알려준다. 함수 본문은 함수가 어떤 계층 구조에 있어야 하는지 알려준다.
- 호출 그래프로 구현이 직접적이지 않다는 것을 알 수 있다. 함수를 호출하는 화살표가 다양한 길이를 가지고 있다면 직접 구현되어 있지 않다는 신호이다.
- 직접 구현 패턴은 함수를 명확하고 아름답게 구현해 계층을 구성할 수 있도록 알려준다.

---

